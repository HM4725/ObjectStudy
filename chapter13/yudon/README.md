## **목차**

1. 상속의 두 가지 목적
2. 타입
3. 서브 클래싱과 서브 타이핑
4. 결론

### 1. 상속의 두가지 목적

- 메인 목적은 **타입 계층 구현,** 이는 객체들간에 관계에 기반하여 확장에 유연한 설계를 가능하게 함
- 동일한 메세지를 다르게 동작 하는 것이 다형적 계층에 기반
1. 타입 계층 구현
    - 부모는 **일반화**, 자식은 **특수화**
2. 코드 재사용
    - 코드 재사용은, 부모와 자식간의 강한 Coupling을 만들기 때문에 주의
    - 부수적인 효과로 생각하는게 더 유익

## 2. 타입

### 1. 프로그래밍적 관점

- 타입에 수행되는 유효한 오퍼레이션 집합
    - Int에선 + 가 덧셈, String에서는 문자열 연결
- 오퍼레이션에 대한 유효한 문맥 제공(약속된 문맥 제공이 원문)
    - Integer 값 덧셈을 위해선, `a + b` 와 같은 형식으로 와야 함.(`ab +` 는 다른 동작이니까~)

### 2. 객체 지향 패러다임 관점

- **Public Interface**(= ****동일한 오퍼레이션을 수행할 수 있는 집합)
- 같은 interface를 가진 객체는 동일한 타입으로 분류 가능(속성, property는 달라도 상관없음!!!!)
- 객체에게 중요한 건 행동, Not 속성

## 3. 서브 클래싱과 서브 타이핑

### 1. 상속 사용 시점

1. is-a관계
2. 행동 호환성(= 클라이언트 입장에서 부모 클래스 타입으로, 자식 클래스 사용)

### 2. is-a 관계

- 일반적인 직관과 다름
- 행동에 따라 타입 계층을 구성하지 않으면, is-a 관계를 만족시킬 수 없음

예시

```swift
새는 날수 있다
펭귄은 새
```

- 펭귄은 새지만, 날 수 없음
- so, 자식 클래스인 `펭귄` 은 부모 클래스인 `새` 대체 불가능

### 3. 행동호환성

- 행동 호환성을 판단하는 기준은 클라이언트
- 클라이언트에선 “새는 날수 있다”로 정의
- 따라서, 이를 만족시키기 위한 새로운 설계 필요

### 4. 클라이언트 기대에 맞는 계층 분리

- 새는 `flying`, `walking` 로 나뉨
- client1는 `flying` 에만 의존, client2는 `walking` 에만 의존
- `Bird` 는 `flying`, `walking` 을 알고 있는 상황
- 이때, `flying` 이 변하더라도, `Bird` 에만 영향을 미치고 `Walking` 에는 영향을 미치지 않음
- 결국, 새라는 인터페이스 하나가 아닌, 두가지 인터페이스를 각자 의존하여 영향을 최소하 함

**인터페이스를 클라이언트 기대에 따라 분리함으로써 변경에 의한 영향을 제어하는 것을 ISP(인터페이스 분리 원칙)이라고 함**

### 5. 서브 클래싱과 서브 타이핑

1. subclassing
- 코드 재사용 목적
1. subtyping
- 행동호환성 보장(자식 클래스가 부모 클래스 대체 가능)

## 4. 결론

- 상속은 타입 계층을 구현하기 위함
- 타입 계층은 동일한 인터페이스를 가지며, 행동 호환성을 확보해야 함(자식이 부모를 대체 가능)
- 타입 계층 분리시, 클라이언트의 기대에 맞는 계층 분리(Not 자연 및 상식)

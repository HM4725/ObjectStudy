## 핵심 결론

- OOP는 함수형과 달리 **객체가 상태를 갖고, 이를 관리하는 것**
- 다형성 사용시, trade-off가 존재(유연성, 재사용성 ↔ 복잡성, 디버깅 난이도)
- 상속의 경우 치명적 단점들이(부모, 자식간 강력한 Coupling) 존재하여, 합성을 처리하는 것이 좋음

### 1. 객체지향 프로그래밍 패러다임

객체를 지향하는 것(단순 class를 만드는 것에 초점 X)

- 객체에게 어떤 상태와 행동을 가질지 결정해야 함
- 객체를 독립적인 존재가 아닌, 협력하는 공동체의 일원으로 생각
    - 이를 통해 설계를 유연하고 확장 가능하게 만듦

→ (번외) 이에 반해 함수형 프로그래밍 패러다임은?

- **상태와 가변데이터를 멀리**하고 수학적 함수로 처리
    - 상태를 멀리하기에 당연히 객체지향과 다른 것

### 2. 객체 접근 제한자

- 객체를 내/외부로 분리
    - 이를 통해, 경계를 명확하게 하고, 객체 자율성 보장
    - 클래스 작성자가 자유롭게 구현을 변경할 수 있음
- interface, implementation을 구분

### 3. 명확성

- Long 타입을 통해서 금액을 나타내고자 함
- 이때 Long 타입을 포함한 구조체를 만들고, 이름을 Money로 한다면?
- 명확성 증가, 유연성 증가 → 복잡성은 다소 증가
- 유연성이 왜 증가할까? 만약 cent라면..? Long인데 ..? 이런걸 대응할 수 있음

### 4. 상속과 다형성

![image](https://github.com/HM4725/ObjectStudy/assets/39371835/fc2e02de-6edc-47fb-8f7a-b96017f43137)


- 추상화 된 객체에 의존하는 케이스
- Movie는 결국 구체화된 객체들인 `AmountDiscountPolicy` , `PercentDiscountPolicy` 에 의존하지 않음(**실행 시점 의존성 ≠ 코드 의존성**)
- 이로인한 `코드 유연성` 및 `재사용성` 증가
- trade-off로 복잡성 증가
    - 디버깅 난이도 상승
    - 코드 이해도 감소

### 5. 코드 재사용성(합성 vs 상속)

합성

- 다른 객체 인스턴스를 인스턴스 변수로 포함해서 사용

상속

- 코드 재사용에 유리
- 단점
    - 캡슐화 위반(부모 클래스 내부 구조를 잘 알아야 함)
    - 부모, 자식 사이에 강력한 Coupling(컴파일 시점에 결합)

# 5장 - 책임 할당

이전 장을 통해 데이터 중심이 아닌, 책임에 초점을 맞추는 것을 배웠다.

하지만, 책임에 초점을 맞춰 설계시에 어떤 객체에게 책임을 할당하기가 쉽지 않다. 

이번 시간에는 이를 배워볼 것이다.


## 책임 주도 설계

책임 주도 설계에 필요한 두가지 원칙이 존재한다.

- 데이터보다 행동을 먼저 결정
- 협력이라는 문맥 안에서 책임을 결정

하지만, 이러한 원칙을 따라 객체의 책임을 설정할 때, 해당 품질은 어떤 요소로 결정할 수 있을까? 

### 책임의 품질

- 책임의 품질은 협력에 적합한 정도로 결정
- 협력의 시작 주체는 메세지 전송자이기에, 그것에 적합한 책임을 할당
- 결국 메세지 전송하는 클라이언트 의도에 적합한 책임 할당

→ “메세지 전송”을 하는 클라이언트 의도에 적합한 책임 할당해야 한다.
”메세지 전송” 즉 **특정 행동을 처리**하기에 **적합한 객체에게 책임을 할당**한다는 것

ex. 유튜브API 객체에서, 사용자ID을 통해 유튜브 채널을 불러올거야.
채널을 불러오기 위해선, URL을 통해서 **네트워크 호출(메세지 전송)**을 해야해

이때, “**네트워크 호출”을** 어떤 객체에게 할당할거야?

(Alamofire, URLSession, 혹은 팀에서 사용하는 네트워크 레이어 객체)

```swift
public class YoutubeAPI {

    public func fetchChannel(userID: String) async throws -> ChannelInformation {
	      let url = self.makeChannelURL(userID: userID)
        let (data, response) = try await URLSession.shared.data(from: url)
        // decoding 
        return result
        
        // or
        let result = try await CommonNetwork.shared.get(url: url)
    } 
     
    private func makeChannelURL(userID: String) -> URL {
        ...
    }
}
```

이제, 각 객체의 책임의 품질을 판단할 수 있다면, 객체의 응집도를 구분하는 기준또한 필요하다.

 이는 어느정도 연결이 되지 않을 수 있다. 객체 책임의 품질을 구분할줄만 알면 되지 않는가? 

한 객체가 캡슐화를 위반하지 않은채 많은 책임을 갖고 있을때, 협력이라는 문맥에선 문제가 없다. 하지만, 응집도의 관점으로는 서로 상관없는 기능들이 한 객체안에 있기 때문에 문제가 된다. 

결국 좋은 객체를 설계하기 위해선, 책임의 품질 판단 근거와 응집도 구분 기준이 필요하다. 

### 클래스 응집도 구분 기준

1. 하나 이상의 이유로 변경된다면 응집도가 낮은 것, 변경의 이유를 기준으로 클래스 분리 
    
    → 단일 책임 원칙에 의해, 한가지 책임 이상을 객체가 담당하고 있음. 변경의 이유(책임) 을 기준으로 클래스를 분리해야 함
    
2. 인스턴스 초기화 시점에, 서로 다른 프로퍼티들 초기화시 응집도가 낮은 것 → 초기화 속성 그룹을 기준으로 클래스 분리
    
    → 한 클래스내에 a,b,c,d,e,f가 존재 이때 a,b,c를 사용하거나 d,c,e를 사용하는 케이스, 이는 결국 분리 대상
    
3. 메서드 그룹간 변수 그룹 사용 여부로 나뉜다면 응집도가 낮은것 → 그룹들간 기준으로 클래스를 분리해야 함
    
    → 메서드간 사용하는 변수 그룹이 다르다면, 분리가 가능(연관 없는 것들끼리 모여있는 것이기 때문에)
